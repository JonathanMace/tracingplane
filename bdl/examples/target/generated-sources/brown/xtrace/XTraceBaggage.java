/** Generated by BaggageBuffersCompiler */
package brown.xtrace;

import brown.tracingplane.ActiveBaggage;
import brown.tracingplane.BaggageContext;
import brown.tracingplane.baggageprotocol.BagKey;
import brown.tracingplane.baggageprotocol.BaggageReader;
import brown.tracingplane.baggageprotocol.BaggageWriter;
import brown.tracingplane.bdl.BDLUtils;
import brown.tracingplane.bdl.Bag;
import brown.tracingplane.bdl.BaggageHandler;
import brown.tracingplane.bdl.Brancher;
import brown.tracingplane.bdl.Branchers;
import brown.tracingplane.bdl.Joiner;
import brown.tracingplane.bdl.Joiners;
import brown.tracingplane.bdl.Parser;
import brown.tracingplane.bdl.Parsers;
import brown.tracingplane.bdl.Serializer;
import brown.tracingplane.bdl.Serializers;
import brown.tracingplane.impl.BDLContextProvider;
import brown.tracingplane.impl.BaggageHandlerRegistry;
import java.util.Set;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class XTraceBaggage implements Bag {

    private static final Logger _log = LoggerFactory.getLogger(XTraceBaggage.class);

    public Long taskId = null;
    public Set<Long> parentEventIds = null;

    public boolean _overflow = false;

    /**
    * <p>
    * Get the {@link XTraceBaggage} set in the active {@link BaggageContext} carried by the current thread. If no baggage is being
    * carried by the current thread, or if there is no XTraceBaggage in it, then this method returns {@code null}.
    * </p>
    *
    * <p>
    * To get XTraceBaggage from a specific Baggage instance, use {@link #getFrom(BaggageContext)}.
    * </p>
    *
    * @return the XTraceBaggage being carried in the {@link BaggageContext} of the current thread, or {@code null}
    *         if none is being carried. The returned instance maybe be modified and modifications will be reflected in
    *         the baggage.
    */
    public static XTraceBaggage get() {
        Bag bag = BDLContextProvider.get(ActiveBaggage.peek(), Handler.registration());
        if (bag instanceof XTraceBaggage) {
            return (XTraceBaggage) bag;
        } else {
            return null;
        }
    }

    /**
    * <p>
    * Get the {@link XTraceBaggage} set in {@code baggage}. If {@code baggage} has no XTraceBaggage set then
    * this method returns null.
    * </p>
    *
    * <p>
    * This method does <b>not</b> affect the Baggage being carried by the current thread.  To get XTraceBaggage
    * from the current thread's Baggage, use {@link #get()}.
    * </p>
    *
    * @param baggage A baggage instance to get the {@link XTraceBaggage} from
    * @return the {@link XTraceBaggage} instance being carried in {@code baggage}, or {@code null} if none is being carried.
    *         The returned instance can be modified, and modifications will be reflected in the baggage.
    */
    public static XTraceBaggage getFrom(BaggageContext baggage) {
        Bag bag = BDLContextProvider.get(baggage, Handler.registration());
        if (bag instanceof XTraceBaggage) {
            return (XTraceBaggage) bag;
        } else if (bag != null) {
            Handler.checkRegistration();
        }
        return null;
    }

    /**
    * <p>
    * Update the {@link XTraceBaggage} set in the current thread's baggage. This method will overwrite any existing
    * XTraceBaggage set in the current thread's baggage.
    * </p>
    *
    * <p>
    * To set the {@link XTraceBaggage} in a specific {@link BaggageContext} instance, use
    * {@link #setIn(BaggageContext, XTraceBaggage)}
    * </p>
    *
    * @param xTraceBaggage the new {@link XTraceBaggage} to set in the current thread's {@link BaggageContext}. If {@code null}
    *            then any existing mappings will be removed.
    */
    public static void set(XTraceBaggage xTraceBaggage) {
        ActiveBaggage.update(BDLContextProvider.set(ActiveBaggage.peek(), Handler.registration(), xTraceBaggage));
    }

    /**
    * <p>
    * Update the {@link XTraceBaggage} set in {@code baggage}. This method will overwrite any existing
    * XTraceBaggage set in {@code baggage}.
    * </p>
    *
    * <p>
    * This method does <b>not</b> affect the {@link BaggageContext} being carried by the current thread. To set the
    * {@link XTraceBaggage} for the current thread, use {@link #set(XTraceBaggage)}
    * </p>
    *
    * @param baggage A baggage instance to set the {@link XTraceBaggage} in
    * @param xTraceBaggage the new XTraceBaggage to set in {@code baggage}. If {@code null}, it will remove any
    *            mapping present.
    * @return a possibly new {@link BaggageContext} instance that contains all previous mappings plus the new mapping.
    */
    public static BaggageContext setIn(BaggageContext baggage, XTraceBaggage xTraceBaggage) {
        return BDLContextProvider.set(baggage, Handler.registration(), xTraceBaggage);
    }

    @Override
    public BaggageHandler<?> handler() {
        return Handler.instance;
    }

    @Override
    public String toString() {
        StringBuilder b = new StringBuilder();
        b.append("XTraceBaggage{\n");
            b.append(this.taskId == null ? "" : BDLUtils.indent(String.format("taskId = %s\n", String.valueOf(this.taskId))));
            b.append(this.parentEventIds == null ? "" : BDLUtils.indent(String.format("parentEventIds = %s\n", BDLUtils.toString(this.parentEventIds))));
            b.append("}");
        return b.toString();
    }

    public static class Handler implements BaggageHandler<XTraceBaggage> {

        public static final Handler instance = new Handler();
        private static BagKey registration = null;

        static synchronized BagKey checkRegistration() {
            registration = BaggageHandlerRegistry.get(instance);
            if (registration == null) {
                _log.error("XTraceBaggage MUST be registered to a key before it can be propagated.  " +
                "There is currently no registration for XTraceBaggage and it will not be propagated. " +
                "To register a bag set the bag.{index} property in your application.conf (eg, for " +
                "index 10, bag.10 = \"brown.xtrace.XTraceBaggage\") or with -Dbag.{index} flag " +
                "(eg, for index 10, -Dbag.10=brown.xtrace.XTraceBaggage)");
            }
            return registration;
        }

        static BagKey registration() {
            return registration == null ? checkRegistration() : registration;
        }

        private Handler(){}

        private static final BagKey _taskIdKey = BagKey.indexed(1);
        private static final BagKey _parentEventIdsKey = BagKey.indexed(2);

        private static final Parser<Long> _taskIdParser = Parsers.fixed64Parser();
        private static final Serializer<Long> _taskIdSerializer = Serializers.fixed64Serializer();
        private static final Brancher<Long> _taskIdBrancher = Branchers.<Long>noop();
        private static final Joiner<Long> _taskIdJoiner = Joiners.<Long>first();

        private static final Parser<Set<Long>> _parentEventIdsParser = Parsers.<Long>setParser(Parsers.fixed64Parser());
        private static final Serializer<Set<Long>> _parentEventIdsSerializer = Serializers.<Long>setSerializer(Serializers.fixed64Serializer());
        private static final Brancher<Set<Long>> _parentEventIdsBrancher = Branchers.<Long>set();
        private static final Joiner<Set<Long>> _parentEventIdsJoiner = Joiners.<Long>setUnion();

        @Override
        public boolean isInstance(Bag bag) {
            return bag == null || bag instanceof XTraceBaggage;
        }

        @Override
        public XTraceBaggage parse(BaggageReader reader) {
            XTraceBaggage instance = new XTraceBaggage();

            if (reader.enter(_taskIdKey)) {
                instance.taskId = _taskIdParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_parentEventIdsKey)) {
                instance.parentEventIds = _parentEventIdsParser.parse(reader);
                reader.exit();
            }
            instance._overflow = reader.didOverflow();

            return instance;
        }

        @Override
        public void serialize(BaggageWriter writer, XTraceBaggage instance) {
            if (instance == null) {
                return;
            }

            writer.didOverflowHere(instance._overflow);

            if (instance.taskId != null) {
                writer.enter(_taskIdKey);
                _taskIdSerializer.serialize(writer, instance.taskId);
                writer.exit();
            }

            if (instance.parentEventIds != null) {
                writer.enter(_parentEventIdsKey);
                _parentEventIdsSerializer.serialize(writer, instance.parentEventIds);
                writer.exit();
            }
        }

        @Override
        public XTraceBaggage branch(XTraceBaggage instance) {
            if (instance == null) {
                return null;
            }

            XTraceBaggage newInstance = new XTraceBaggage();
            newInstance.taskId = _taskIdBrancher.branch(instance.taskId);
            newInstance.parentEventIds = _parentEventIdsBrancher.branch(instance.parentEventIds);
            return newInstance;
        }

        @Override
        public XTraceBaggage join(XTraceBaggage left, XTraceBaggage right) {
            if (left == null) {
                return right;
            } else if (right == null) {
                return left;
            } else {
                left.taskId = _taskIdJoiner.join(left.taskId, right.taskId);
                left.parentEventIds = _parentEventIdsJoiner.join(left.parentEventIds, right.parentEventIds);
                return left;
            }
        }
    }
}