/** Generated by BaggageBuffersCompiler */
package brown.tracingplane.bdl.examples;

import brown.tracingplane.ActiveBaggage;
import brown.tracingplane.BaggageContext;
import brown.tracingplane.baggageprotocol.BagKey;
import brown.tracingplane.baggageprotocol.BaggageReader;
import brown.tracingplane.baggageprotocol.BaggageWriter;
import brown.tracingplane.bdl.BDLUtils;
import brown.tracingplane.bdl.Bag;
import brown.tracingplane.bdl.BaggageHandler;
import brown.tracingplane.bdl.Brancher;
import brown.tracingplane.bdl.Branchers;
import brown.tracingplane.bdl.CounterImpl;
import brown.tracingplane.bdl.Joiner;
import brown.tracingplane.bdl.Joiners;
import brown.tracingplane.bdl.Parser;
import brown.tracingplane.bdl.Parsers;
import brown.tracingplane.bdl.ReaderHelpers;
import brown.tracingplane.bdl.Serializer;
import brown.tracingplane.bdl.Serializers;
import brown.tracingplane.bdl.SpecialTypes.Counter;
import brown.tracingplane.bdl.Struct;
import brown.tracingplane.bdl.WriterHelpers;
import brown.tracingplane.bdl.examples.SimpleBag;
import brown.tracingplane.bdl.examples.SimpleBag2;
import brown.tracingplane.bdl.examples.SimpleStruct1;
import brown.tracingplane.impl.BDLContextProvider;
import brown.tracingplane.impl.BaggageHandlerRegistry;
import java.util.Map;
import java.util.Set;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class ExampleBag implements Bag {

    private static final Logger _log = LoggerFactory.getLogger(ExampleBag.class);

    public Boolean boolfield = null;
    public Integer int32field = null;
    public Integer sint32field = null;
    public Integer fixed32field = null;
    public Integer sfixed32field = null;
    public Long int64field = null;
    public Long sint64field = null;
    public Long fixed64field = null;
    public Long sfixed64field = null;
    public String stringfield = null;
    public java.nio.ByteBuffer bytesfield = null;
    public Set<Integer> int32set = null;
    public Set<String> stringset = null;
    public SimpleBag simpleBag = null;
    public Set<String> simpleBag2 = null;
    public Map<String, SimpleBag2> bagMap = null;
    public Counter c = null;
    public Boolean sampled = false;
    public SimpleStruct1 structfield = null;
    public Set<SimpleStruct1> structsetfield = null;
    public Map<String, Counter> countermap = null;

    public boolean _overflow = false;

    /**
    * <p>
    * Get the {@link ExampleBag} set in the active {@link BaggageContext} carried by the current thread. If no baggage is being
    * carried by the current thread, or if there is no ExampleBag in it, then this method returns {@code null}.
    * </p>
    *
    * <p>
    * To get ExampleBag from a specific Baggage instance, use {@link #getFrom(BaggageContext)}.
    * </p>
    *
    * @return the ExampleBag being carried in the {@link BaggageContext} of the current thread, or {@code null}
    *         if none is being carried. The returned instance maybe be modified and modifications will be reflected in
    *         the baggage.
    */
    public static ExampleBag get() {
        Bag bag = BDLContextProvider.get(ActiveBaggage.peek(), Handler.registration());
        if (bag instanceof ExampleBag) {
            return (ExampleBag) bag;
        } else {
            return null;
        }
    }

    /**
    * <p>
    * Get the {@link ExampleBag} set in {@code baggage}. If {@code baggage} has no ExampleBag set then
    * this method returns null.
    * </p>
    *
    * <p>
    * This method does <b>not</b> affect the Baggage being carried by the current thread.  To get ExampleBag
    * from the current thread's Baggage, use {@link #get()}.
    * </p>
    *
    * @param baggage A baggage instance to get the {@link ExampleBag} from
    * @return the {@link ExampleBag} instance being carried in {@code baggage}, or {@code null} if none is being carried.
    *         The returned instance can be modified, and modifications will be reflected in the baggage.
    */
    public static ExampleBag getFrom(BaggageContext baggage) {
        Bag bag = BDLContextProvider.get(baggage, Handler.registration());
        if (bag instanceof ExampleBag) {
            return (ExampleBag) bag;
        } else if (bag != null) {
            Handler.checkRegistration();
        }
        return null;
    }

    /**
    * <p>
    * Update the {@link ExampleBag} set in the current thread's baggage. This method will overwrite any existing
    * ExampleBag set in the current thread's baggage.
    * </p>
    *
    * <p>
    * To set the {@link ExampleBag} in a specific {@link BaggageContext} instance, use
    * {@link #setIn(BaggageContext, ExampleBag)}
    * </p>
    *
    * @param exampleBag the new {@link ExampleBag} to set in the current thread's {@link BaggageContext}. If {@code null}
    *            then any existing mappings will be removed.
    */
    public static void set(ExampleBag exampleBag) {
        ActiveBaggage.update(BDLContextProvider.set(ActiveBaggage.peek(), Handler.registration(), exampleBag));
    }

    /**
    * <p>
    * Update the {@link ExampleBag} set in {@code baggage}. This method will overwrite any existing
    * ExampleBag set in {@code baggage}.
    * </p>
    *
    * <p>
    * This method does <b>not</b> affect the {@link BaggageContext} being carried by the current thread. To set the
    * {@link ExampleBag} for the current thread, use {@link #set(ExampleBag)}
    * </p>
    *
    * @param baggage A baggage instance to set the {@link ExampleBag} in
    * @param exampleBag the new ExampleBag to set in {@code baggage}. If {@code null}, it will remove any
    *            mapping present.
    * @return a possibly new {@link BaggageContext} instance that contains all previous mappings plus the new mapping.
    */
    public static BaggageContext setIn(BaggageContext baggage, ExampleBag exampleBag) {
        return BDLContextProvider.set(baggage, Handler.registration(), exampleBag);
    }

    @Override
    public BaggageHandler<?> handler() {
        return Handler.instance;
    }

    @Override
    public String toString() {
        StringBuilder b = new StringBuilder();
        b.append("ExampleBag{\n");
            b.append(this.boolfield == null ? "" : BDLUtils.indent(String.format("boolfield = %s\n", String.valueOf(this.boolfield))));
            b.append(this.int32field == null ? "" : BDLUtils.indent(String.format("int32field = %s\n", String.valueOf(this.int32field))));
            b.append(this.sint32field == null ? "" : BDLUtils.indent(String.format("sint32field = %s\n", String.valueOf(this.sint32field))));
            b.append(this.fixed32field == null ? "" : BDLUtils.indent(String.format("fixed32field = %s\n", String.valueOf(this.fixed32field))));
            b.append(this.sfixed32field == null ? "" : BDLUtils.indent(String.format("sfixed32field = %s\n", String.valueOf(this.sfixed32field))));
            b.append(this.int64field == null ? "" : BDLUtils.indent(String.format("int64field = %s\n", String.valueOf(this.int64field))));
            b.append(this.sint64field == null ? "" : BDLUtils.indent(String.format("sint64field = %s\n", String.valueOf(this.sint64field))));
            b.append(this.fixed64field == null ? "" : BDLUtils.indent(String.format("fixed64field = %s\n", String.valueOf(this.fixed64field))));
            b.append(this.sfixed64field == null ? "" : BDLUtils.indent(String.format("sfixed64field = %s\n", String.valueOf(this.sfixed64field))));
            b.append(this.stringfield == null ? "" : BDLUtils.indent(String.format("stringfield = %s\n", String.valueOf(this.stringfield))));
            b.append(this.bytesfield == null ? "" : BDLUtils.indent(String.format("bytesfield = %s\n", String.valueOf(this.bytesfield))));
            b.append(this.int32set == null ? "" : BDLUtils.indent(String.format("int32set = %s\n", BDLUtils.toString(this.int32set))));
            b.append(this.stringset == null ? "" : BDLUtils.indent(String.format("stringset = %s\n", BDLUtils.toString(this.stringset))));
            b.append(this.simpleBag == null ? "" : BDLUtils.indent(String.format("simpleBag = %s\n", String.valueOf(this.simpleBag))));
            b.append(this.simpleBag2 == null ? "" : BDLUtils.indent(String.format("simpleBag2 = %s\n", BDLUtils.toString(this.simpleBag2))));
            b.append(this.bagMap == null ? "" : BDLUtils.indent(String.format("bagMap = %s\n", BDLUtils.toString(this.bagMap, _v0 -> String.valueOf(_v0)))));
            b.append(this.c == null ? "" : BDLUtils.indent(String.format("c = %s\n", String.valueOf(this.c))));
            b.append(this.sampled == null ? "" : BDLUtils.indent(String.format("sampled = %s\n", String.valueOf(this.sampled))));
            b.append(this.structfield == null ? "" : BDLUtils.indent(String.format("structfield = %s\n", String.valueOf(this.structfield))));
            b.append(this.structsetfield == null ? "" : BDLUtils.indent(String.format("structsetfield = %s\n", BDLUtils.toString(this.structsetfield))));
            b.append(this.countermap == null ? "" : BDLUtils.indent(String.format("countermap = %s\n", BDLUtils.toString(this.countermap, _v0 -> String.valueOf(_v0)))));
            b.append("}");
        return b.toString();
    }

    public static class Handler implements BaggageHandler<ExampleBag> {

        public static final Handler instance = new Handler();
        private static BagKey registration = null;

        static synchronized BagKey checkRegistration() {
            registration = BaggageHandlerRegistry.get(instance);
            if (registration == null) {
                _log.error("ExampleBag MUST be registered to a key before it can be propagated.  " +
                "There is currently no registration for ExampleBag and it will not be propagated. " +
                "To register a bag set the bag.{index} property in your application.conf (eg, for " +
                "index 10, bag.10 = \"brown.tracingplane.bdl.examples.ExampleBag\") or with -Dbag.{index} flag " +
                "(eg, for index 10, -Dbag.10=brown.tracingplane.bdl.examples.ExampleBag)");
            }
            return registration;
        }

        static BagKey registration() {
            return registration == null ? checkRegistration() : registration;
        }

        private Handler(){}

        private static final BagKey _boolfieldKey = BagKey.indexed(0);
        private static final BagKey _int32fieldKey = BagKey.indexed(1);
        private static final BagKey _sint32fieldKey = BagKey.indexed(2);
        private static final BagKey _fixed32fieldKey = BagKey.indexed(3);
        private static final BagKey _sfixed32fieldKey = BagKey.indexed(4);
        private static final BagKey _int64fieldKey = BagKey.indexed(5);
        private static final BagKey _sint64fieldKey = BagKey.indexed(6);
        private static final BagKey _fixed64fieldKey = BagKey.indexed(7);
        private static final BagKey _sfixed64fieldKey = BagKey.indexed(8);
        private static final BagKey _stringfieldKey = BagKey.indexed(9);
        private static final BagKey _bytesfieldKey = BagKey.indexed(10);
        private static final BagKey _int32setKey = BagKey.indexed(11);
        private static final BagKey _stringsetKey = BagKey.indexed(12);
        private static final BagKey _simpleBagKey = BagKey.indexed(15);
        private static final BagKey _simpleBag2Key = BagKey.indexed(16);
        private static final BagKey _bagMapKey = BagKey.indexed(20);
        private static final BagKey _cKey = BagKey.indexed(23);
        private static final BagKey _sampledKey = BagKey.indexed(30);
        private static final BagKey _structfieldKey = BagKey.indexed(33);
        private static final BagKey _structsetfieldKey = BagKey.indexed(34);
        private static final BagKey _countermapKey = BagKey.indexed(35);

        private static final Parser<Boolean> _boolfieldParser = Parsers.boolParser();
        private static final Serializer<Boolean> _boolfieldSerializer = Serializers.boolSerializer();
        private static final Brancher<Boolean> _boolfieldBrancher = Branchers.<Boolean>noop();
        private static final Joiner<Boolean> _boolfieldJoiner = Joiners.<Boolean>first();

        private static final Parser<Integer> _int32fieldParser = Parsers.int32Parser();
        private static final Serializer<Integer> _int32fieldSerializer = Serializers.int32Serializer();
        private static final Brancher<Integer> _int32fieldBrancher = Branchers.<Integer>noop();
        private static final Joiner<Integer> _int32fieldJoiner = Joiners.<Integer>first();

        private static final Parser<Integer> _sint32fieldParser = Parsers.sint32Parser();
        private static final Serializer<Integer> _sint32fieldSerializer = Serializers.sint32Serializer();
        private static final Brancher<Integer> _sint32fieldBrancher = Branchers.<Integer>noop();
        private static final Joiner<Integer> _sint32fieldJoiner = Joiners.<Integer>first();

        private static final Parser<Integer> _fixed32fieldParser = Parsers.fixed32Parser();
        private static final Serializer<Integer> _fixed32fieldSerializer = Serializers.fixed32Serializer();
        private static final Brancher<Integer> _fixed32fieldBrancher = Branchers.<Integer>noop();
        private static final Joiner<Integer> _fixed32fieldJoiner = Joiners.<Integer>first();

        private static final Parser<Integer> _sfixed32fieldParser = Parsers.sfixed32Parser();
        private static final Serializer<Integer> _sfixed32fieldSerializer = Serializers.sfixed32Serializer();
        private static final Brancher<Integer> _sfixed32fieldBrancher = Branchers.<Integer>noop();
        private static final Joiner<Integer> _sfixed32fieldJoiner = Joiners.<Integer>first();

        private static final Parser<Long> _int64fieldParser = Parsers.int64Parser();
        private static final Serializer<Long> _int64fieldSerializer = Serializers.int64Serializer();
        private static final Brancher<Long> _int64fieldBrancher = Branchers.<Long>noop();
        private static final Joiner<Long> _int64fieldJoiner = Joiners.<Long>first();

        private static final Parser<Long> _sint64fieldParser = Parsers.sint64Parser();
        private static final Serializer<Long> _sint64fieldSerializer = Serializers.sint64Serializer();
        private static final Brancher<Long> _sint64fieldBrancher = Branchers.<Long>noop();
        private static final Joiner<Long> _sint64fieldJoiner = Joiners.<Long>first();

        private static final Parser<Long> _fixed64fieldParser = Parsers.fixed64Parser();
        private static final Serializer<Long> _fixed64fieldSerializer = Serializers.fixed64Serializer();
        private static final Brancher<Long> _fixed64fieldBrancher = Branchers.<Long>noop();
        private static final Joiner<Long> _fixed64fieldJoiner = Joiners.<Long>first();

        private static final Parser<Long> _sfixed64fieldParser = Parsers.sfixed64Parser();
        private static final Serializer<Long> _sfixed64fieldSerializer = Serializers.sfixed64Serializer();
        private static final Brancher<Long> _sfixed64fieldBrancher = Branchers.<Long>noop();
        private static final Joiner<Long> _sfixed64fieldJoiner = Joiners.<Long>first();

        private static final Parser<String> _stringfieldParser = Parsers.stringParser();
        private static final Serializer<String> _stringfieldSerializer = Serializers.stringSerializer();
        private static final Brancher<String> _stringfieldBrancher = Branchers.<String>noop();
        private static final Joiner<String> _stringfieldJoiner = Joiners.<String>first();

        private static final Parser<java.nio.ByteBuffer> _bytesfieldParser = Parsers.bytesParser();
        private static final Serializer<java.nio.ByteBuffer> _bytesfieldSerializer = Serializers.bytesSerializer();
        private static final Brancher<java.nio.ByteBuffer> _bytesfieldBrancher = Branchers.<java.nio.ByteBuffer>noop();
        private static final Joiner<java.nio.ByteBuffer> _bytesfieldJoiner = Joiners.<java.nio.ByteBuffer>first();

        private static final Parser<Set<Integer>> _int32setParser = Parsers.<Integer>setParser(Parsers.int32Parser());
        private static final Serializer<Set<Integer>> _int32setSerializer = Serializers.<Integer>setSerializer(Serializers.int32Serializer());
        private static final Brancher<Set<Integer>> _int32setBrancher = Branchers.<Integer>set();
        private static final Joiner<Set<Integer>> _int32setJoiner = Joiners.<Integer>setUnion();

        private static final Parser<Set<String>> _stringsetParser = Parsers.<String>setParser(Parsers.stringParser());
        private static final Serializer<Set<String>> _stringsetSerializer = Serializers.<String>setSerializer(Serializers.stringSerializer());
        private static final Brancher<Set<String>> _stringsetBrancher = Branchers.<String>set();
        private static final Joiner<Set<String>> _stringsetJoiner = Joiners.<String>setUnion();

        private static final BaggageHandler<SimpleBag> _simpleBagHandler = SimpleBag.Handler.instance;

        private static final Parser<Set<String>> _simpleBag2Parser = Parsers.<String>setParser(Parsers.stringParser());
        private static final Serializer<Set<String>> _simpleBag2Serializer = Serializers.<String>setSerializer(Serializers.stringSerializer());
        private static final Brancher<Set<String>> _simpleBag2Brancher = Branchers.<String>set();
        private static final Joiner<Set<String>> _simpleBag2Joiner = Joiners.<String>setUnion();

        private static final Parser<Map<String, SimpleBag2>> _bagMapParser = Parsers.<String,SimpleBag2>mapParser(ReaderHelpers.to_string, SimpleBag2.Handler.instance);
        private static final Serializer<Map<String, SimpleBag2>> _bagMapSerializer = Serializers.<String,SimpleBag2>mapSerializer(WriterHelpers.from_string, SimpleBag2.Handler.instance);
        private static final Brancher<Map<String, SimpleBag2>> _bagMapBrancher = Branchers.<String, SimpleBag2>map(SimpleBag2.Handler.instance);
        private static final Joiner<Map<String, SimpleBag2>> _bagMapJoiner = Joiners.<String, SimpleBag2>mapMerge(SimpleBag2.Handler.instance);

        private static final BaggageHandler<? extends Counter> _cHandler = CounterImpl.Handler.instance;

        private static final Parser<Boolean> _sampledParser = Parsers.taintParser();
        private static final Serializer<Boolean> _sampledSerializer = Serializers.taintSerializer();
        private static final Brancher<Boolean> _sampledBrancher = Branchers.<Boolean>noop();
        private static final Joiner<Boolean> _sampledJoiner = Joiners.or();

        private static final Struct.StructHandler<SimpleStruct1> _structfieldHandler = SimpleStruct1.Handler.instance;
        private static final Brancher<SimpleStruct1> _structfieldBrancher = Branchers.<SimpleStruct1>noop();
        private static final Joiner<SimpleStruct1> _structfieldJoiner = Joiners.<SimpleStruct1>first();

        private static final Parser<Set<SimpleStruct1>> _structsetfieldParser = Parsers.<SimpleStruct1>setParser(SimpleStruct1.Handler.instance);
        private static final Serializer<Set<SimpleStruct1>> _structsetfieldSerializer = Serializers.<SimpleStruct1>setSerializer(SimpleStruct1.Handler.instance);
        private static final Brancher<Set<SimpleStruct1>> _structsetfieldBrancher = Branchers.<SimpleStruct1>set();
        private static final Joiner<Set<SimpleStruct1>> _structsetfieldJoiner = Joiners.<SimpleStruct1>setUnion();

        private static final Parser<Map<String, Counter>> _countermapParser = Parsers.<String,Counter>mapParser(ReaderHelpers.to_string, (Parser)CounterImpl.Handler.instance);
        private static final Serializer<Map<String, Counter>> _countermapSerializer = Serializers.<String,Counter>mapSerializer(WriterHelpers.from_string, (Serializer)CounterImpl.Handler.instance);
        private static final Brancher<Map<String, Counter>> _countermapBrancher = Branchers.<String, Counter>map((Brancher)CounterImpl.Handler.instance);
        private static final Joiner<Map<String, Counter>> _countermapJoiner = Joiners.<String, Counter>mapMerge((Joiner)CounterImpl.Handler.instance);

        @Override
        public boolean isInstance(Bag bag) {
            return bag == null || bag instanceof ExampleBag;
        }

        @Override
        public ExampleBag parse(BaggageReader reader) {
            ExampleBag instance = new ExampleBag();

            if (reader.enter(_boolfieldKey)) {
                instance.boolfield = _boolfieldParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_int32fieldKey)) {
                instance.int32field = _int32fieldParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_sint32fieldKey)) {
                instance.sint32field = _sint32fieldParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_fixed32fieldKey)) {
                instance.fixed32field = _fixed32fieldParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_sfixed32fieldKey)) {
                instance.sfixed32field = _sfixed32fieldParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_int64fieldKey)) {
                instance.int64field = _int64fieldParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_sint64fieldKey)) {
                instance.sint64field = _sint64fieldParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_fixed64fieldKey)) {
                instance.fixed64field = _fixed64fieldParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_sfixed64fieldKey)) {
                instance.sfixed64field = _sfixed64fieldParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_stringfieldKey)) {
                instance.stringfield = _stringfieldParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_bytesfieldKey)) {
                instance.bytesfield = _bytesfieldParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_int32setKey)) {
                instance.int32set = _int32setParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_stringsetKey)) {
                instance.stringset = _stringsetParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_simpleBagKey)) {
                instance.simpleBag = _simpleBagHandler.parse(reader);
                reader.exit();
            }

            if (reader.enter(_simpleBag2Key)) {
                instance.simpleBag2 = _simpleBag2Parser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_bagMapKey)) {
                instance.bagMap = _bagMapParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_cKey)) {
                instance.c = _cHandler.parse(reader);
                reader.exit();
            }

            if (reader.enter(_sampledKey)) {
                instance.sampled = _sampledParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_structfieldKey)) {
                instance.structfield = _structfieldHandler.parse(reader);
                reader.exit();
            }

            if (reader.enter(_structsetfieldKey)) {
                instance.structsetfield = _structsetfieldParser.parse(reader);
                reader.exit();
            }

            if (reader.enter(_countermapKey)) {
                instance.countermap = _countermapParser.parse(reader);
                reader.exit();
            }
            instance._overflow = reader.didOverflow();

            return instance;
        }

        @Override
        public void serialize(BaggageWriter writer, ExampleBag instance) {
            if (instance == null) {
                return;
            }

            writer.didOverflowHere(instance._overflow);

            if (instance.boolfield != null) {
                writer.enter(_boolfieldKey);
                _boolfieldSerializer.serialize(writer, instance.boolfield);
                writer.exit();
            }

            if (instance.int32field != null) {
                writer.enter(_int32fieldKey);
                _int32fieldSerializer.serialize(writer, instance.int32field);
                writer.exit();
            }

            if (instance.sint32field != null) {
                writer.enter(_sint32fieldKey);
                _sint32fieldSerializer.serialize(writer, instance.sint32field);
                writer.exit();
            }

            if (instance.fixed32field != null) {
                writer.enter(_fixed32fieldKey);
                _fixed32fieldSerializer.serialize(writer, instance.fixed32field);
                writer.exit();
            }

            if (instance.sfixed32field != null) {
                writer.enter(_sfixed32fieldKey);
                _sfixed32fieldSerializer.serialize(writer, instance.sfixed32field);
                writer.exit();
            }

            if (instance.int64field != null) {
                writer.enter(_int64fieldKey);
                _int64fieldSerializer.serialize(writer, instance.int64field);
                writer.exit();
            }

            if (instance.sint64field != null) {
                writer.enter(_sint64fieldKey);
                _sint64fieldSerializer.serialize(writer, instance.sint64field);
                writer.exit();
            }

            if (instance.fixed64field != null) {
                writer.enter(_fixed64fieldKey);
                _fixed64fieldSerializer.serialize(writer, instance.fixed64field);
                writer.exit();
            }

            if (instance.sfixed64field != null) {
                writer.enter(_sfixed64fieldKey);
                _sfixed64fieldSerializer.serialize(writer, instance.sfixed64field);
                writer.exit();
            }

            if (instance.stringfield != null) {
                writer.enter(_stringfieldKey);
                _stringfieldSerializer.serialize(writer, instance.stringfield);
                writer.exit();
            }

            if (instance.bytesfield != null) {
                writer.enter(_bytesfieldKey);
                _bytesfieldSerializer.serialize(writer, instance.bytesfield);
                writer.exit();
            }

            if (instance.int32set != null) {
                writer.enter(_int32setKey);
                _int32setSerializer.serialize(writer, instance.int32set);
                writer.exit();
            }

            if (instance.stringset != null) {
                writer.enter(_stringsetKey);
                _stringsetSerializer.serialize(writer, instance.stringset);
                writer.exit();
            }

            if (instance.simpleBag != null) {
                writer.enter(_simpleBagKey);
                _simpleBagHandler.serialize(writer, instance.simpleBag);
                writer.exit();
            }

            if (instance.simpleBag2 != null) {
                writer.enter(_simpleBag2Key);
                _simpleBag2Serializer.serialize(writer, instance.simpleBag2);
                writer.exit();
            }

            if (instance.bagMap != null) {
                writer.enter(_bagMapKey);
                _bagMapSerializer.serialize(writer, instance.bagMap);
                writer.exit();
            }

            if (instance.c != null) {
                writer.enter(_cKey);
                _cHandler.serialize(writer, instance.c);
                writer.exit();
            }

            if (instance.sampled != null) {
                writer.enter(_sampledKey);
                _sampledSerializer.serialize(writer, instance.sampled);
                writer.exit();
            }

            if (instance.structfield != null) {
                writer.enter(_structfieldKey);
                _structfieldHandler.serialize(writer, instance.structfield);
                writer.exit();
            }

            if (instance.structsetfield != null) {
                writer.enter(_structsetfieldKey);
                _structsetfieldSerializer.serialize(writer, instance.structsetfield);
                writer.exit();
            }

            if (instance.countermap != null) {
                writer.enter(_countermapKey);
                _countermapSerializer.serialize(writer, instance.countermap);
                writer.exit();
            }
        }

        @Override
        public ExampleBag branch(ExampleBag instance) {
            if (instance == null) {
                return null;
            }

            ExampleBag newInstance = new ExampleBag();
            newInstance.boolfield = _boolfieldBrancher.branch(instance.boolfield);
            newInstance.int32field = _int32fieldBrancher.branch(instance.int32field);
            newInstance.sint32field = _sint32fieldBrancher.branch(instance.sint32field);
            newInstance.fixed32field = _fixed32fieldBrancher.branch(instance.fixed32field);
            newInstance.sfixed32field = _sfixed32fieldBrancher.branch(instance.sfixed32field);
            newInstance.int64field = _int64fieldBrancher.branch(instance.int64field);
            newInstance.sint64field = _sint64fieldBrancher.branch(instance.sint64field);
            newInstance.fixed64field = _fixed64fieldBrancher.branch(instance.fixed64field);
            newInstance.sfixed64field = _sfixed64fieldBrancher.branch(instance.sfixed64field);
            newInstance.stringfield = _stringfieldBrancher.branch(instance.stringfield);
            newInstance.bytesfield = _bytesfieldBrancher.branch(instance.bytesfield);
            newInstance.int32set = _int32setBrancher.branch(instance.int32set);
            newInstance.stringset = _stringsetBrancher.branch(instance.stringset);
            newInstance.simpleBag = _simpleBagHandler.branch(instance.simpleBag);
            newInstance.simpleBag2 = _simpleBag2Brancher.branch(instance.simpleBag2);
            newInstance.bagMap = _bagMapBrancher.branch(instance.bagMap);
            newInstance.c = _cHandler.branch(instance.c);
            newInstance.sampled = _sampledBrancher.branch(instance.sampled);
            newInstance.structfield = _structfieldBrancher.branch(instance.structfield);
            newInstance.structsetfield = _structsetfieldBrancher.branch(instance.structsetfield);
            newInstance.countermap = _countermapBrancher.branch(instance.countermap);
            return newInstance;
        }

        @Override
        public ExampleBag join(ExampleBag left, ExampleBag right) {
            if (left == null) {
                return right;
            } else if (right == null) {
                return left;
            } else {
                left.boolfield = _boolfieldJoiner.join(left.boolfield, right.boolfield);
                left.int32field = _int32fieldJoiner.join(left.int32field, right.int32field);
                left.sint32field = _sint32fieldJoiner.join(left.sint32field, right.sint32field);
                left.fixed32field = _fixed32fieldJoiner.join(left.fixed32field, right.fixed32field);
                left.sfixed32field = _sfixed32fieldJoiner.join(left.sfixed32field, right.sfixed32field);
                left.int64field = _int64fieldJoiner.join(left.int64field, right.int64field);
                left.sint64field = _sint64fieldJoiner.join(left.sint64field, right.sint64field);
                left.fixed64field = _fixed64fieldJoiner.join(left.fixed64field, right.fixed64field);
                left.sfixed64field = _sfixed64fieldJoiner.join(left.sfixed64field, right.sfixed64field);
                left.stringfield = _stringfieldJoiner.join(left.stringfield, right.stringfield);
                left.bytesfield = _bytesfieldJoiner.join(left.bytesfield, right.bytesfield);
                left.int32set = _int32setJoiner.join(left.int32set, right.int32set);
                left.stringset = _stringsetJoiner.join(left.stringset, right.stringset);
                left.simpleBag = _simpleBagHandler.join(left.simpleBag, right.simpleBag);
                left.simpleBag2 = _simpleBag2Joiner.join(left.simpleBag2, right.simpleBag2);
                left.bagMap = _bagMapJoiner.join(left.bagMap, right.bagMap);
                left.c = _cHandler.join(left.c, right.c);
                left.sampled = _sampledJoiner.join(left.sampled, right.sampled);
                left.structfield = _structfieldJoiner.join(left.structfield, right.structfield);
                left.structsetfield = _structsetfieldJoiner.join(left.structsetfield, right.structsetfield);
                left.countermap = _countermapJoiner.join(left.countermap, right.countermap);
                return left;
            }
        }
    }
}